package service

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	clusterDataStore "github.com/stackrox/rox/central/cluster/datastore"
	clusterDataStoreMocks "github.com/stackrox/rox/central/cluster/datastore/mocks"
	roleDataStore "github.com/stackrox/rox/central/role/datastore"
	roleDataStoreMocks "github.com/stackrox/rox/central/role/datastore/mocks"
	v1 "github.com/stackrox/rox/generated/internalapi/central/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/auth/tokens"
	tokensMocks "github.com/stackrox/rox/pkg/auth/tokens/mocks"
	"github.com/stackrox/rox/pkg/errox"
	"github.com/stackrox/rox/pkg/grpc/authn"
	authnMocks "github.com/stackrox/rox/pkg/grpc/authn/mocks"
	"github.com/stackrox/rox/pkg/protoassert"
	"github.com/stackrox/rox/pkg/protomock"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
	"google.golang.org/protobuf/types/known/durationpb"
)

const testSensorClusterID = "cluster 1"

var (
	errDummy = errors.New("test error")

	// permissivePolicy allows the permissions used in existing tests.
	permissivePolicy = newTokenPolicy(1*time.Hour, map[string]v1.Access{
		"Deployment": v1.Access_READ_ACCESS,
		"Image":      v1.Access_READ_ACCESS,
	})
)

// sensorContext returns a context with a mock sensor identity injected.
func sensorContext(t testing.TB, ctrl *gomock.Controller, clusterID string) context.Context {
	mockIdentity := authnMocks.NewMockIdentity(ctrl)
	mockIdentity.EXPECT().Service().Return(&storage.ServiceIdentity{
		Id:   clusterID,
		Type: storage.ServiceType_SENSOR_SERVICE,
	}).AnyTimes()
	return authn.ContextWithIdentity(t.Context(), mockIdentity, t)
}

func TestGetExpiresAt(t *testing.T) {
	for name, tc := range map[string]struct {
		input              *v1.GenerateTokenForPermissionsAndScopeRequest
		expectsErr         bool
		expectedExpiration time.Time
	}{
		"nil input": {
			input:      nil,
			expectsErr: true,
		},
		"input without requested validity": {
			input: &v1.GenerateTokenForPermissionsAndScopeRequest{
				Lifetime: nil,
			},
			expectsErr: true,
		},
		"input with invalid requested validity": {
			input: &v1.GenerateTokenForPermissionsAndScopeRequest{
				Lifetime: &durationpb.Duration{
					Seconds: 60,
					Nanos:   -654321987,
				},
			},
			expectsErr: true,
		},
		"input with negative requested validity": {
			input: &v1.GenerateTokenForPermissionsAndScopeRequest{
				Lifetime: &durationpb.Duration{
					Seconds: -60,
					Nanos:   -654321987,
				},
			},
			expectsErr: true,
		},
		"valid input": {
			input: &v1.GenerateTokenForPermissionsAndScopeRequest{
				Lifetime: &durationpb.Duration{
					Seconds: 300,
				},
			},
			expectsErr:         false,
			expectedExpiration: testTokenExpiry,
		},
	} {
		t.Run(name, func(it *testing.T) {
			svc := newServiceImpl(nil, nil, testClock, permissivePolicy)
			expiresAt, err := svc.getExpiresAt(it.Context(), tc.input)
			if tc.expectsErr {
				fmt.Println(err.Error())
				assert.Error(it, err)
				assert.Zero(it, expiresAt)
			} else {
				assert.NoError(it, err)
				assert.Equal(it, tc.expectedExpiration, expiresAt)
			}
		})
	}
}

func TestGenerateTokenForPermissionsAndScope(t *testing.T) {
	deploymentPermission := map[string]v1.Access{
		"Deployment": v1.Access_READ_ACCESS,
	}
	requestSingleNamespace := &v1.ClusterScope{
		ClusterId:         testSensorClusterID,
		FullClusterAccess: false,
		Namespaces:        []string{"namespace A"},
	}
	deploymentPS := testPermissionSet(deploymentPermission)
	singleNSScope := testAccessScope(
		[]*v1.ClusterScope{requestSingleNamespace},
	)
	expectedRole := testRole(
		deploymentPermission,
		[]*v1.ClusterScope{requestSingleNamespace},
	)

	createService := func(
		issuer tokens.Issuer,
		clusterStore clusterDataStore.DataStore,
		roleStore roleDataStore.DataStore,
		policy *tokenPolicy,
	) *serviceImpl {
		return newServiceImpl(
			issuer,
			&roleManager{
				clusterStore: clusterStore,
				roleStore:    roleStore,
			},
			testClock,
			policy,
		)
	}

	t.Run("no requested validity", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      nil,
		}

		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
	})
	t.Run("failed role creation", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}

		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)
		mockRoleStore.EXPECT().
			UpsertPermissionSet(
				gomock.Any(),
				protomock.GoMockMatcherEqualMessage(deploymentPS),
			).Times(1).Return(errDummy)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
	})
	t.Run("token issuer failure", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}

		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		mockIssuer := tokensMocks.NewMockIssuer(mockCtrl)
		svc := createService(mockIssuer, mockClusterStore, mockRoleStore, permissivePolicy)
		setClusterStoreExpectations(input, mockClusterStore)
		setNormalRoleStoreExpectations(deploymentPS, singleNSScope, expectedRole, nil, mockRoleStore)
		expectedClaims := tokens.RoxClaims{
			RoleNames: []string{expectedRole.GetName()},
			Name: fmt.Sprintf(
				claimNameFormat,
				expectedRole.GetName(),
				testTokenExpiry.Format(time.RFC3339Nano),
			),
		}
		mockIssuer.EXPECT().
			Issue(gomock.Any(), expectedClaims, gomock.Any()).
			Times(1).Return(nil, errDummy)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
	})
	t.Run("success", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}

		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		mockIssuer := tokensMocks.NewMockIssuer(mockCtrl)
		svc := createService(mockIssuer, mockClusterStore, mockRoleStore, permissivePolicy)
		setClusterStoreExpectations(input, mockClusterStore)
		setNormalRoleStoreExpectations(deploymentPS, singleNSScope, expectedRole, nil, mockRoleStore)
		expectedClaims := tokens.RoxClaims{
			RoleNames: []string{expectedRole.GetName()},
			Name: fmt.Sprintf(
				"Generated claims for role %s expiring at %s",
				expectedRole.GetName(),
				testTokenExpiry.Format(time.RFC3339Nano),
			),
		}
		mockIssuer.EXPECT().
			Issue(gomock.Any(), expectedClaims, gomock.Any()).
			Times(1).Return(&tokens.TokenInfo{Token: "the quick brown fox jumps over the lazy dog"}, nil)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.NotNil(it, rsp)
		protoassert.Equal(
			it,
			&v1.GenerateTokenForPermissionsAndScopeResponse{
				Token: "the quick brown fox jumps over the lazy dog",
			},
			rsp,
		)
		assert.NoError(it, err)
	})
	t.Run("missing identity rejects request", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}
		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)

		// Use a plain context without identity.
		rsp, err := svc.GenerateTokenForPermissionsAndScope(it.Context(), input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
		assert.ErrorIs(it, err, errox.NotAuthorized)
	})
	t.Run("non-sensor service identity rejects request", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}
		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)

		// Use a context with a non-sensor service identity.
		mockIdentity := authnMocks.NewMockIdentity(mockCtrl)
		mockIdentity.EXPECT().Service().Return(&storage.ServiceIdentity{
			Id:   "some-service-id",
			Type: storage.ServiceType_CENTRAL_SERVICE,
		}).AnyTimes()
		ctx := authn.ContextWithIdentity(it.Context(), mockIdentity, it)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
		assert.ErrorIs(it, err, errox.NotAuthorized)
	})
	t.Run("permission not in allowlist rejects request", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions: map[string]v1.Access{
				"NetworkGraph": v1.Access_READ_ACCESS,
			},
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}
		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
		assert.ErrorIs(it, err, errox.InvalidArgs)
	})
	t.Run("access level exceeds allowlist rejects request", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions: map[string]v1.Access{
				"Deployment": v1.Access_READ_WRITE_ACCESS,
			},
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			Lifetime:      testExpirationDuration,
		}
		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
		assert.ErrorIs(it, err, errox.InvalidArgs)
	})
	t.Run("cluster scope mismatch rejects request", func(it *testing.T) {
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions: deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{
				{ClusterId: "other-cluster", Namespaces: []string{"ns"}},
			},
			Lifetime: testExpirationDuration,
		}
		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		svc := createService(nil, mockClusterStore, mockRoleStore, permissivePolicy)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.Nil(it, rsp)
		assert.Error(it, err)
		assert.ErrorIs(it, err, errox.InvalidArgs)
	})
	t.Run("lifetime capping", func(it *testing.T) {
		shortMaxPolicy := newTokenPolicy(10*time.Second, map[string]v1.Access{
			"Deployment": v1.Access_READ_ACCESS,
		})
		input := &v1.GenerateTokenForPermissionsAndScopeRequest{
			Permissions:   deploymentPermission,
			ClusterScopes: []*v1.ClusterScope{requestSingleNamespace},
			// 300 seconds requested, but policy caps at 10 seconds.
			Lifetime: testExpirationDuration,
		}

		cappedExpiry := testClock().Add(10 * time.Second)
		cappedTraits, traitErr := generateTraitsWithExpiry(cappedExpiry.Add(rbacObjectsGraceExpiration))
		assert.NoError(it, traitErr)

		cappedPS := &storage.PermissionSet{
			Id:               computePermissionSetID(deploymentPermission),
			Name:             fmt.Sprintf(permissionSetNameFormat, computePermissionSetID(deploymentPermission)),
			Description:      permissionSetDescription,
			ResourceToAccess: map[string]storage.Access{"Deployment": storage.Access_READ_ACCESS},
			Traits:           cappedTraits,
		}
		cappedScope := computeAccessScopeID([]*v1.ClusterScope{requestSingleNamespace})
		cappedAS := &storage.SimpleAccessScope{
			Id:          cappedScope,
			Name:        fmt.Sprintf(accessScopeNameFormat, cappedScope),
			Description: accessScopeDescription,
			Rules: &storage.SimpleAccessScope_Rules{
				IncludedClusters: make([]string, 0),
				IncludedNamespaces: []*storage.SimpleAccessScope_Rules_Namespace{
					{ClusterName: testSensorClusterID, NamespaceName: "namespace A"},
				},
			},
			Traits: cappedTraits,
		}
		cappedRoleName := fmt.Sprintf(roleNameFormat, cappedPS.GetId(), cappedAS.GetId())
		cappedRole := &storage.Role{
			Name:            cappedRoleName,
			Description:     roleDescription,
			PermissionSetId: cappedPS.GetId(),
			AccessScopeId:   cappedAS.GetId(),
			Traits:          cappedTraits,
		}

		mockCtrl := gomock.NewController(it)
		mockClusterStore := clusterDataStoreMocks.NewMockDataStore(mockCtrl)
		mockRoleStore := roleDataStoreMocks.NewMockDataStore(mockCtrl)
		mockIssuer := tokensMocks.NewMockIssuer(mockCtrl)
		svc := createService(mockIssuer, mockClusterStore, mockRoleStore, shortMaxPolicy)
		setClusterStoreExpectations(input, mockClusterStore)
		mockRoleStore.EXPECT().
			UpsertPermissionSet(gomock.Any(), protomock.GoMockMatcherEqualMessage(cappedPS)).
			Times(1).Return(nil)
		mockRoleStore.EXPECT().
			UpsertAccessScope(gomock.Any(), protomock.GoMockMatcherEqualMessage(cappedAS)).
			Times(1).Return(nil)
		mockRoleStore.EXPECT().
			UpsertRole(gomock.Any(), protomock.GoMockMatcherEqualMessage(cappedRole)).
			Times(1).Return(nil)
		expectedClaims := tokens.RoxClaims{
			RoleNames: []string{cappedRoleName},
			Name: fmt.Sprintf(
				claimNameFormat,
				cappedRoleName,
				cappedExpiry.Format(time.RFC3339Nano),
			),
		}
		mockIssuer.EXPECT().
			Issue(gomock.Any(), expectedClaims, gomock.Any()).
			Times(1).Return(&tokens.TokenInfo{Token: "capped-token"}, nil)
		ctx := sensorContext(it, mockCtrl, testSensorClusterID)

		rsp, err := svc.GenerateTokenForPermissionsAndScope(ctx, input)
		assert.NotNil(it, rsp)
		assert.NoError(it, err)
		assert.Equal(it, "capped-token", rsp.GetToken())
	})
}
